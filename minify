#!/usr/bin/python2.7

import httplib, urllib, sys, os.path

# Define the parameters for the POST request and encode them in
# a URL-safe format.


class MinifyException(Exception):
    def __init__(self, message=None):
        self.message = message
        super(MinifyException, self).__init__(self.message)

    def __repr__(self):
        return self.message


class Filename():
    def __init__(self, filename):
        path, file = os.path.split(filename)
        self._oldname = filename
        file_parts = file.split('.')
        self._name = file_parts[0]
        self._nparts = len(file_parts)
        self._path = path
        if len(file_parts) > 1:
            self._extension = file_parts[-1]
        else:
            self._extension = ''
        self._new = ''

    def isJs(self):
        '''Return true if file has js extension'''
        return self._extension == 'js'
        
    def isMinifiable(self):
        ''' As a convention this program will ignore all files of the format
        "name.<string>.js." This serves two purposes.  One, we ignore
        already minified js files (i.e name.min.js).  And two, we allow for
        the creation of file named, for example name.max.js, that should not
        be minified.''' 
        return self.isJs() and (self._nparts == 2)
        
    def isUpToDate(self):
        '''Check timestamps to see if output file is 'newer' than the input'''
        try:
            return os.path.getmtime(self.getNewName()) > \
                   os.path.getmtime(self._oldname)
        except OSError:
            return 0

    def getOriginal(self):
        '''Return the original filename'''
        return self._oldname
        
    def getNewName(self):
        '''Make the new filename and 'cache' the result'''
        if not self._new:
            self._new = os.path.join(self._path, self._name + '.min.js')
        return self._new            

def read(filename):
    with open(filename, 'r') as f:
        output = f.read()
    return output

def write(filename, input):
    with open(filename, 'w') as f:
        f.write(input)

def sendreceive(input, num):
    compiler_level = ['WHITESPACE_ONLY', 'SIMPLE_OPTIMIZATIONS', 
        'ADVANCED_OPTIMIZATIONS']
    params = urllib.urlencode([
        ('js_code', input),
        ('compilation_level', compiler_level[num]),
        ('output_format', 'text'),
        ('output_info', 'compiled_code'),
      ])

    # Always use the following value for the Content-type header.
    headers = { "Content-type": "application/x-www-form-urlencoded" }
    conn = httplib.HTTPConnection('closure-compiler.appspot.com')
    conn.request('POST', '/compile', params, headers)
    response = conn.getresponse()
    data = response.read()
    conn.close()
    return data

def newer(filename, path):
    try:
        return os.path.getmtime(os.path.join(path, filename + '.min.js')) > \
               os.path.getmtime(os.path.join(path, filename + '.js')) 
    except:
        return 0

def manpage():
    print "usage: minify [-c COMPILER_LEVEL] [-f] file [file] ..."
    print "\t-c, --compiler-level COMPILER_LEVEL"
    print "\t\t0: Whitespace removal only"
    print "\t\t1: Simple Optimizations (default)"
    print "\t\t2: Advanced Optimizations"
    print "\t-f, --force"
    print "\t\t Force the evaluation of all js files"
    print "\t-v, --verbose"
    print "\t-h, --help"
    print
    print "Examples:"
    print "\tminify -c 2 -f static/this.js"
    print "\tminify static/*"

def main(filename, num, force=0, verbose=0):
    file = Filename(filename)
    #path, filename = os.path.split(file)
    
    print "%s..." % filename,
    sys.stdout.flush()
    filenameparts = filename.split('.')
    if file.isMinifiable():
        if not force and file.isUpToDate():
            print "up-to-date"
        else:
            if verbose:
                print
            try:
                try:
                    if verbose:
                        print "\treading file...",
                    content = read(file.getOriginal())
                except IOError as e:
                    print "read error"
                    if verbose:
                        print e
                    raise
                else:
                    if verbose:
                        print "done"
                try:
                    if verbose:
                        print "\tprocessing file...",
                    data = sendreceive(content, num)
                except (IOError, ValueError, UnicodeError, TypeError) as e:
                    print "connection error"
                    if verbose:
                        print e
                    raise
                else:
                    if verbose:
                        print "done"
                try:
                    if verbose:
                        print "\twriting output file...",
                    write(file.getNewName(), data)
                except IOError as e:
                    print "write error"
                    if verbose:
                        print e
                    raise
                else:
                    if verbose:
                        print "done"
            except (IOError, ValueError, UnicodeError, TypeError):
                if verbose:
                    print "failed"
            else:
                print "done"
    elif not file.isJs():
        print "not javascript file"
    else:
        print "skipped"

if __name__ == '__main__':
    COMPILER_LEVEL = 1 #Default is 1
    FORCE = False #Default is False
    VERBOSE = False

    args = sys.argv[1:]

    try:
        for n, arg in enumerate(sys.argv):
            if arg == '-c' or arg == '--compiler-level':
                try:
                    value = int(sys.argv[n+1])
                except ValueError:
                    raise MinifyException('No compilation number')
                args.remove(sys.argv[n+1])
                if value not in (0, 1, 2):
                    raise MinifyException("Invalid compilation number")
                COMPILER_LEVEL = value
                args.remove(arg)
            elif arg == '-f' or arg == '--force':
                FORCE = True
                args.remove(arg)
            elif arg == '-v' or arg == '--verbose':
                VERBOSE = True
                args.remove(arg)
            elif arg == '-h' or arg == '--help':
                args = []

        for filename in args:
            main(filename, COMPILER_LEVEL, FORCE, VERBOSE)

        if len(args) == 0:
            manpage()
    except MinifyException as e:
        if VERBOSE:
            print e
        manpage()
